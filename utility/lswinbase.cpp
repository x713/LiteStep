/*
This is a part of the LiteStep Shell Source code.

Copyright (C) 1997-2002 The LiteStep Development Team

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
/****************************************************************************
****************************************************************************/

#define STRSAFE_NO_DEPRECATE
#include "lswinbase.h"

const unsigned int GWL_CLASSPOINTER = 0;


struct CreationData
{
  SHORT cbExtra;
  Window* window;
};

typedef UNALIGNED CreationData UACreationData;


const wchar_t defaultClassName[] = L"AutoWindowClass";


LPCWSTR Window::className = defaultClassName;
WNDCLASSEX Window::windowClass;
DWORD Window::instanceCount = 0;
HINSTANCE Window::hInstance = 0;


//---------------------------------------------------------
// Constructor
//---------------------------------------------------------
Window::Window(LPCWSTR wszClassName) :
  hWnd(NULL),
  hParent(NULL)
{
  WNDCLASSEX& wc = windowClass;

  if (!hInstance)
    MessageBox(NULL, L"ERROR: Please call Window::init()", wszClassName,
      MB_ICONINFORMATION | MB_TOPMOST);

  instanceCount++;
  if (instanceCount > 1)
    return;


  if (className != defaultClassName)
  {
    delete[] const_cast<LPWSTR>(className);
    className = defaultClassName;
  }

  if (wszClassName)
  {
    size_t len = wcslen(wszClassName) + 1;
    wcscpy_s((LPWSTR)className, len, wszClassName);
  }

  memset(&wc, 0, sizeof(WNDCLASSEX));
  wc.cbSize = sizeof(WNDCLASSEX);
  wc.cbWndExtra = sizeof(Window*);
  wc.hCursor = LoadCursor(NULL, IDC_ARROW);
  wc.lpfnWndProc = Window::wndProc;
  wc.hInstance = hInstance;
  wc.lpszClassName = className;

  if (!RegisterClassEx(&wc))
  {
    // Class could not be registered, try to re-register
    UnregisterClass(className, hInstance);

    if (!RegisterClassEx(&wc))
    {
      // Still no luck, error out
      MessageBox(NULL, L"Unable to register window class.", className,
        MB_ICONEXCLAMATION | MB_TOPMOST);
      throw;
    }
  }
}


//---------------------------------------------------------
// Destructor
//---------------------------------------------------------
Window::~Window()
{
  destroyWindow();
  if (instanceCount > 0)
    instanceCount--;
  if (instanceCount > 0)
    return;

  UnregisterClass(className, hInstance);
  if (className != defaultClassName)
    delete[] const_cast<LPWSTR>(className);
}


//---------------------------------------------------------
// Returns the handle to the class' window
//---------------------------------------------------------
const HWND Window::handle() const
{
  return hWnd;
}


//---------------------------------------------------------
// Creates a new window and links it with the class
//---------------------------------------------------------
bool Window::createWindow(DWORD dwExStyle, LPCWSTR lpWindowName, DWORD dwStyle,
  int x, int y, int nWidth, int nHeight, HWND hWndParent)
{
  UACreationData creationData = { sizeof(UACreationData), this };

  if (hWnd && !destroyWindow())
  {
    MessageBox(NULL, L"Unable to destroy existing window.", className,
      MB_ICONEXCLAMATION | MB_TOPMOST);
    throw;
  }

  hParent = hWndParent;

  hWnd = CreateWindowEx(dwExStyle, className, lpWindowName, dwStyle,
    x, y, nWidth, nHeight, hParent, NULL, hInstance, &creationData);
  if (!hWnd)
    return false;

  return true;
}



//---------------------------------------------------------
// Destroys the window associated with the class
//---------------------------------------------------------
bool Window::destroyWindow()
{
  if (hWnd && DestroyWindow(hWnd))
    return true;
  return false;
}


//---------------------------------------------------------
// If the window is associated with a class, call the
// messsage handler of the class
//---------------------------------------------------------
LRESULT CALLBACK Window::wndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  Message message = { 0 };
  message.uMsg = uMsg;
  message.wParam = wParam;
  message.lParam = lParam;

  Window* window = NULL;

  if (uMsg == WM_CREATE)
  {
    LPVOID& lpCreateParams = LPCREATESTRUCT(lParam)->lpCreateParams;

    if (lpCreateParams)
    {
      window = ((UACreationData*)(lpCreateParams))->window;
      SetWindowLongPtr(hWnd, GWL_CLASSPOINTER, (LONG_PTR)window);
    }
  }
  else
    window = (Window*)(GetWindowLongPtr(hWnd, GWL_CLASSPOINTER));

  if (window)
  {
    if (uMsg == WM_CREATE) {
      window->hWnd = hWnd;
    }
    window->windowProc(message);
    if (uMsg == WM_NCDESTROY) {
      window->hWnd = NULL;
    }
    return message.lResult;
  }
  return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


//---------------------------------------------------------
// Empty skeleton for messsage handling
//---------------------------------------------------------
void Window::windowProc(Message& message)
{
  message.lResult = DefWindowProc(hWnd, message.uMsg, message.wParam, message.lParam);
}


void Window::init(HINSTANCE hInst)
{
  hInstance = hInst;
}

HINSTANCE Window::instance()
{
  return hInstance;
}
